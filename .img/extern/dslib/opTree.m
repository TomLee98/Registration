classdef opTree < handle
    %OPTREE This class defines a tree which stored a structured tree 
    % comes from regohm object 
    
    properties (Access = private, Hidden)
        tree    (1,1)   struct
    end
    
    methods
        function this = opTree(root, mode)
            %OPTREE A constructor
            arguments
                root    (1,1)   matlab.ui.container.Tree
                mode    (1,1)   string  {mustBeMember(mode, ["save", "all"])} = "save"
            end

            % use recursion to copy the Tree
            % generate struct dynamically
            this.tree.Type = 'tree';
            this.tree.Tag = '';
            this.tree.Children = cell(1, numel(root.Children));
            for k = 1:numel(root.Children)
                this.tree.Children{k} = opTree.treeNodesToStruct(root.Children(k), mode);
            end
        end
        
        % This function restores uitree on given tree root
        function root = Restore(this, root, cm)
            arguments
                this
                root    (1,1)   matlab.ui.container.Tree
                cm      (1,1)   matlab.ui.container.ContextMenu
            end

            for k = 1:numel(this.tree.Children)
                root.Children(k) = opTree.structToTreeNode(root, cm, this.tree.Children{k});
            end
        end
    end

    methods (Static)
        function tree = treeNodesToStruct(node, mode)
            arguments
                node    (1,1)   matlab.ui.container.TreeNode
                mode    (1,1)   string  {mustBeMember(mode, ["save", "all"])} = "save"
            end
            % 将uitree及其所有子节点转换为结构体
            % 输入：root - 树对象（uitree）
            % 输出：tree - 包含所有节点信息的结构体
            % generated by 豆包 AI

            % 获取当前节点的基本属性
            tree = struct();
            tree.Text = node.Text;
            tree.Tag = node.Tag;
            tree.Type = 'treenode';
            tree.NodeData = node.NodeData;
            switch mode
                case "save"
                    % free link to avoid copy data in disk
                    tree.NodeData.RSPoint.freelink();
                    tree.NodeData.RSPoint
                otherwise
            end

            % 递归处理子节点
            if ~isempty(node.Children)
                children = node.Children;
                childStructs = cell(1, length(children));

                for i = 1:length(children)
                    childStructs{i} = opTree.treeNodesToStruct(children(i));
                end

                tree.Children = childStructs;
            else
                tree.Children = []; % 无子节点时设为空
            end
        end

        function cNode = structToTreeNode(pNode, cm, ns)
            % 创建当前节点
            cNode = uitreenode(pNode, "Text",ns.Text, "NodeData",ns.NodeData, ...
                "ContextMenu",cm);
            cNode.NodeData.RSPoint.relink();

            % 递归添加子节点
            if ~isempty(ns.Children)
                for k = 1:length(ns.Children)
                    cNode.Children(k) = structToTreeNode(cNode, cm, ns.Children{k});
                end
            end
        end
    end
end


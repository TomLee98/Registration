classdef InformationCollector < handle
    %INFORMATIONCOLLECTOR This class defines an information collector which
    %could generate encrypted operations log files and send to remote host
    %on LabNas if possible

    properties(Access = public, Constant)
        VER = "1.0.0"
    end

    properties(Access = private, Constant, Hidden)
        COMPONENTS_DELIMITER = " | "
    end
    
    properties(Access = private, Hidden)
        folder              (1,1)   string
        info_file           (1,1)   string
        is_connected        (1,1)   logical
        scoder              (1,1)   
    end

    properties(Access = public, Dependent)
        Status
    end
    
    methods
        function r = get.Status(this)
            if this.is_connected
                r = "Connected";
            else
                r = "Disconnected";
            end
        end
    end

    methods (Access = public)
        function this = InformationCollector(status_default)
            arguments
                status_default  (1,1)   string  {mustBeMember(status_default, ["ONLINE", "OFFLINE"])} = "ONLINE"
            end
            %INFORMATIONCOLLECTOR A constructor

            this.scoder = aesobj();

            switch status_default
                case "ONLINE"
                    if ispc()
                        eval(this.scoder.decrypt(constdef.RIF_PC));
                    elseif isunix()
                        eval(this.scoder.decrypt(constdef.RIF_UNIX));
                    else
                        throw(MException("InformationCollector:unsupportPlatform", ...
                            "Only windows and unix are supported."));
                    end

                    [~, hname] = system('hostname');
                    hname = strtrim(hname);
                    hname_encryted = this.scoder.encrypt(hname);

                    % REMOTE_INFORMATION_FOLDER
                    this.folder = REMOTE_INFORMATION_FOLDER;
                    try
                        % try to access
                        if isfolder(this.folder)
                            files_exists = struct2table(dir(this.folder));
                            files_exists = string(files_exists.name);
                            files_exists(~files_exists.contains(constdef.LOG_FILE_EXT)) = [];
                            while true
                                % generate new file name
                                info_file_ = InformationCollector.genfilename(this.folder);
                                [~, fname, ext] = fileparts(info_file_);
                                fname = [fname, ext]; %#ok<AGROW>
                                if ~ismember(string(fname), files_exists)
                                    this.info_file = info_file_;
                                    break;
                                end
                            end

                            % open file and write basic information
                            [~, hwinfo] = GetHardwareInfo();
                            pe = pyenv;
                            tbx_in = squeeze(string(struct2cell(ver)))';
                            tbx_in = tbx_in(:, 1);  % take the first columns: name

                            fid = fopen(this.info_file, "a+");

                            fprintf(fid, "########## Log File Automatically Generated by " + ...
                                "Information Collector ##########\r\n");
                            fprintf(fid, "[Host Name] %s\r\n", hname_encryted);
                            fprintf(fid, "[Creation Time] %s\r\n", string(datetime("now")));
                            fprintf(fid, "[CPU Info] %s\r\n", ...
                                join(hwinfo.cpu, this.COMPONENTS_DELIMITER));
                            fprintf(fid, "[GPU Info] %s\r\n", ...
                                join(hwinfo.gpu, this.COMPONENTS_DELIMITER));
                            fprintf(fid, "[Memory Info] %s\r\n", ...
                                replace(hwinfo.mem, newline, this.COMPONENTS_DELIMITER));
                            fprintf(fid, "[MATLAB Version] %s\r\n", version);
                            fprintf(fid, "[Toolbox Installed] %s\r\n", ...
                                join(tbx_in, this.COMPONENTS_DELIMITER));
                            fprintf(fid, "[Java Version] %s\r\n", version('-java'));
                            fprintf(fid, "[Python Version] %s%s%s\r\n", ...
                                pe.Version, this.COMPONENTS_DELIMITER, pe.Home);
                            fprintf(fid, "[Register Version] %s%s%s\r\n", Register.VER, ...
                                this.COMPONENTS_DELIMITER, Register.RELEASE_STATUS);
                            fprintf(fid, "[InformationCollector Version] %s\r\n", this.VER);
                            fprintf(fid, "\r\n########## Operations Queue Automatically Generated by " + ...
                                "Reg3D ##########\r\n");
                            fclose(fid);

                            this.is_connected = true;
                        else
                            this.is_connected = false;
                        end
                    catch
                        this.is_connected = false;
                    end
                case "OFFLINE"
                    this.is_connected = false;
                otherwise
            end
        end

        function Push(this, app, obj, exception)
            arguments
                this
                app         (1,1)   string
                obj         (1,1)   string
                exception   (1,1)   string  = "None"
            end

            if this.is_connected == true
                try
                    % reformat the message as pipeline
                    str = sprintf("%s%s%s%s%s%s%s", ...
                        string(datetime("now")), this.COMPONENTS_DELIMITER, ...
                        app, this.COMPONENTS_DELIMITER, ...
                        obj, this.COMPONENTS_DELIMITER, ...
                        exception);

                    str_encrypted = this.scoder.encrypt(str);

                    fid = fopen(this.info_file, "a+");

                    fprintf(fid, "%s\r\n", str_encrypted);

                    fclose(fid);
                catch ME
                    this.is_connected = false;
                    throw(ME);
                end
            end
        end
    end

    methods(Static, Hidden)
        function file_ = genfilename(folder_)
            rng('shuffle');     % make sure a random generation

            % generate file name code: 18 chars
            code_idx = [randi(26,1,6)+64, randi(26,1,6)+96, randi(10,1,6)+47];

            % random suffix for avoiding same filename
            % and hidden the file information
            filename_ = char(code_idx(randperm(18)));

            if isstring(folder_), folder_ = folder_.char(); end

            file_ = [folder_, filesep, filename_, char(constdef.LOG_FILE_EXT)];
        end
    end
end

